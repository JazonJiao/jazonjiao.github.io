D5P209-190424
12`On 4/23 and 4/24, I spent 20+ hours building up a new part of my Manim.js library for visualizing Graph Algorithms, which is very fun and involved a lot of coordinate geometry calculations.
13`Now, it seems that I spend almost twice as much time studying than normally—up to 12 hours a day, but much of the time is actually inefficiently debugging or configuring my program or even fixing legacy code, and the intensity of my work is pretty low. So, the overall output has not changed much—I basically only study one algorithm per day. Building this visualization tool could even count as a relaxation.
13`Reaching 4/27, as my animation tools get increasingly sophisticated, coding it isn’t as easy and relaxing as before, as I need to keep track of a lot of things simultaneously in my memory. I’m trying to keep good practices while coding—name things consistently, keeping good documentation—so that I would be less painful in the future.
14`I feel that I really like this intensity and complexity—I like this feeling of burning my brain. Why do I feel good in coding up this complex machine, when I feel painful in other intense times? First, it gives me a great sense of achievement to see all those beautiful animations.
13`Second, although it’s hard, I already understand the basics and know how to start the thinking, and I know I will always figure it out with enough time. This is not like the things I deal with this semester, which are often what I’ve never seen before, things that I have no idea how to start learning in the first place.
13`One way to distinguish the two situations is: in the former case, I already understand a concept and can think about it purely in my head, or code without any external resources. When I code, I clearly know what I’m about to do, and I know what the result should be. So, even if a concept is very complex, it’s still fun to learn and I will immerse in it.
13`In the latter case, I don’t even have a basic idea of what’s going on, and have to read a lot just to get a foundation for understanding the concept. Of course, the former is a much more satisfying experience; but for any concept, with enough practice, I could turn the latter situation into the former.
11`Look at CS-3281, when I need to constantly look up how the manual page of a system call, which is basically impossible to understand, and when I write code, I don’t quite know the purpose and desired results either.
11`OS and CS-2231 are the most annoying courses I’ve taken—I feel sorry saying this since the professors are super nice and responsible, but generally I can hardly get myself to like the stuff we’re learning. For OS, we have a great textbook, a few assignments with the style I like, i.e. implementing a certain logic, and I must admit that what everything we learn is useful—for example, knowledge about C language and files came up in CS-3258.
11`But more often than not, assignments deal with system commands that can only take painful trial and errors, instead of logical explorations, to get right. To make things worse, the Windows OS cannot handle many system calls, and I have to use a Linux Virtual Machine to run code and do assignments, which is super inconvenient and always crashes my computer unless I reboot frequently.
11`Especially for the final project, much of the time is spent debugging, which involves messing around with commands randomly until it somehow gets right. Keep this experience in mind—when I ever encounter something like this in the workforce, I’ll get very painful. The way to get out is to instead try to write data structure code.
