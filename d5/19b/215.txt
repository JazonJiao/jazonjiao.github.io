D5P215-190510
12`On 5/10, I was still focusing on my Graph Algorithm visualization project, when I was stuck on a problem: how to generate a random shuffling of an array. I then searched the internet and found a Leetcode problem about it (Prob. 384).
12`I then restarted Leetcode, months after solving only 11 problems in the winter and then forgetting about it. And since then, I’ve been spending much of my studying time on Leetcode solving problems or otherwise learning about Python, and it’s pretty satisfactory. I personally feel that shuati on Leetcode is a lot easier and less painful than learning stuff from the Algorithms class.
14`Now as I’m working on D5P211, I’m also concurrently exploring the best way to learn from Leetcode. I aim at solving 500 problems (although I aimed for 1,000 back in January…), but quality is more important than quality, and for some good problems, I can resolve it using many different methods. Whatever the number, the principle is to spend about 500 hours from 5/10 to the end of 2019 on shuati.
12`I just added the number of “assisted” problems in my daily tally. Sometimes I am stuck on a problem for more than a few hours, usually because I could not meet the given time or space complexity requirements, or because I fail on a few special test cases, and feel that I will need an entirely different method that I cannot discover by myself. I can then resort to the solutions and, after thoroughly understanding it or coding it myself, add it to the “assisted” problems list.
13`I think it’s better for me to, say, solve 4 problems every day than to solve 8 problems every other day. This way, I can digest the problems and techniques better, and remember them in the long run.
13`When solving a hard problem, it’s often the case that I encounter many dead ends, before finding a correct solution or resort to hints. I should reflect on the methods I try during the exploration.
13`For days, I can concentrate on shuati for several hours straight, and enjoy it very much. On 5/16 I suddenly recalled how I felt “I can’t have sustained focus when studying data structures” back in D5P187-190117. I then realized the importance of the Algorithm class I took, as well as my hard work for this class. They are crucial preparation for Leetcode.
13`Taking the CS-3250 class, of course, is vastly different than shuati. I would say that in general, I take a bottom-up, input-driven approach to the class, but a top-down, output-driven approach to shuati. I came to realize the distinction between these two modes of studying first in D5P209-190424: the former means I need to understand a difficult concept by digesting information, while the latter is to output my thoughts based on what I already know; the latter is generally much easier and more satisfying.
13`The algorithms we learned in class are so hard that we often don’t know how it’s derived. Up till now I still don’t know why MTM have to take O(n^3) while OBST takes only O(n^2), i.e. how the reduction trick in the latter’s DP algorithm works; or why the Big-5 Algorithm cannot run with arrays of 3 numbers. I also don’t quite know, say, how to prove the correctness Prim’s, Kruskal’s, and Dijkstra’s algorithms. These are so hard that the professor doesn’t require us to know. We often only need to know the steps of the algorithm as well as when to use them.
13`Less than half of what we learned in class is directly related to shuati. But that doesn’t mean the course isn’t useful. After the rigorous training, I can understand techniques such as dynamic programming, DFS or other graph/tree traversal algorithms; and analyses such as time complexity, much more easily. Enjoyable top-down learning can only be possible after painful bottom-up studying.
13`And these methods can be adapted in unexpected ways. For example, the principle of Dijkstra’s Algorithm comes up in Prob. 64, although it’s a 2D array problem.
13`Another difference between the course and shuati is that in shuati, we need to care about implementation and syntactical details. Learning about Python’s utility classes and their interfaces sometimes need memorization. But oftentimes, these kinds of memorization can also deepen one’s understanding of data structures.
12`I seem to be good at some kinds of problems than at others. Even “Hard” tree problems seem easy for me, while some “Medium” array problems are unintuitive.
12`By 5/20, here are some caveats for Leetcode that I’ve found. First, I sometimes have the temptation to get my program to “beat 99% of submissions” in terms of runtime. Some experienced coders have argued that obsessing with efficiency is nonsensical when what’s more important is to write clean, readable code. Also, the runtime measurement is not stable: when my code is identical to another person’s submission, sometimes the runtimes are different.
12`Second, in order to pass all tests, I sometimes have to deal with some nasty edge conditions that may cause me to do extra hours of debugging. I’m not saying it’s not beneficial to care about edge cases, but it sometimes deviates from the main goal, especially when the original program is already basically correct.
13`Third, solving on Leetcode can cause me to make certain assumptions about problems. For example, usually string problems say that the input letters will always be lowercase, so I gradually began to assume string problems always concern lowercase letters, and so failed on LC 345.
